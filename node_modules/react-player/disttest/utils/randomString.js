var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/load-script/index.js
var require_load_script = __commonJS({
  "node_modules/load-script/index.js"(exports, module) {
    module.exports = function load(src, opts, cb) {
      var head = document.head || document.getElementsByTagName("head")[0];
      var script = document.createElement("script");
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      opts = opts || {};
      cb = cb || function() {
      };
      script.type = opts.type || "text/javascript";
      script.charset = opts.charset || "utf8";
      script.async = "async" in opts ? !!opts.async : true;
      script.src = src;
      if (opts.attrs) {
        setAttributes(script, opts.attrs);
      }
      if (opts.text) {
        script.text = "" + opts.text;
      }
      var onend = "onload" in script ? stdOnEnd : ieOnEnd;
      onend(script, cb);
      if (!script.onload) {
        stdOnEnd(script, cb);
      }
      head.appendChild(script);
    };
    function setAttributes(script, attrs) {
      for (var attr in attrs) {
        script.setAttribute(attr, attrs[attr]);
      }
    }
    function stdOnEnd(script, cb) {
      script.onload = function() {
        this.onerror = this.onload = null;
        cb(null, script);
      };
      script.onerror = function() {
        this.onerror = this.onload = null;
        cb(new Error("Failed to load " + this.src), script);
      };
    }
    function ieOnEnd(script, cb) {
      script.onreadystatechange = function() {
        if (this.readyState != "complete" && this.readyState != "loaded")
          return;
        this.onreadystatechange = null;
        cb(null, script);
      };
    }
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// test/utils/randomString.js
import { test } from "zora";

// src/utils.js
var import_load_script = __toESM(require_load_script());
var import_deepmerge = __toESM(require_cjs());
function randomString() {
  return Math.random().toString(36).substr(2, 5);
}
function getGlobal(key) {
  if (window[key]) {
    return window[key];
  }
  if (window.exports && window.exports[key]) {
    return window.exports[key];
  }
  if (window.module && window.module.exports && window.module.exports[key]) {
    return window.module.exports[key];
  }
  return null;
}
var requests = {};
var getSDK = enableStubOn(function getSDK2(url, sdkGlobal, sdkReady = null, isLoaded = () => true, fetchScript = import_load_script.default) {
  const existingGlobal = getGlobal(sdkGlobal);
  if (existingGlobal && isLoaded(existingGlobal)) {
    return Promise.resolve(existingGlobal);
  }
  return new Promise((resolve, reject) => {
    if (requests[url]) {
      requests[url].push({ resolve, reject });
      return;
    }
    requests[url] = [{ resolve, reject }];
    const onLoaded = (sdk) => {
      requests[url].forEach((request) => request.resolve(sdk));
    };
    if (sdkReady) {
      const previousOnReady = window[sdkReady];
      window[sdkReady] = function() {
        if (previousOnReady)
          previousOnReady();
        onLoaded(getGlobal(sdkGlobal));
      };
    }
    fetchScript(url, (err) => {
      if (err) {
        requests[url].forEach((request) => request.reject(err));
        requests[url] = null;
      } else if (!sdkReady) {
        onLoaded(getGlobal(sdkGlobal));
      }
    });
  });
});
function enableStubOn(fn) {
  if (true) {
    const wrap = (...args) => wrap.stub(...args);
    wrap.stub = fn;
    return wrap;
  }
  return fn;
}

// test/utils/randomString.js
test("returns a 5 character string", (t) => {
  t.is(typeof randomString(), "string");
  t.is(randomString().length, 5);
});
test("returns different strings", (t) => {
  const a = randomString();
  const b = randomString();
  const c = randomString();
  t.isNot(a, b);
  t.isNot(a, c);
  t.isNot(b, c);
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL2xvYWQtc2NyaXB0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanMiLCAiLi4vLi4vdGVzdC91dGlscy9yYW5kb21TdHJpbmcuanMiLCAiLi4vLi4vc3JjL3V0aWxzLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbG9hZCAoc3JjLCBvcHRzLCBjYikge1xuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXVxuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIGNiID0gY2IgfHwgZnVuY3Rpb24oKSB7fVxuXG4gIHNjcmlwdC50eXBlID0gb3B0cy50eXBlIHx8ICd0ZXh0L2phdmFzY3JpcHQnXG4gIHNjcmlwdC5jaGFyc2V0ID0gb3B0cy5jaGFyc2V0IHx8ICd1dGY4JztcbiAgc2NyaXB0LmFzeW5jID0gJ2FzeW5jJyBpbiBvcHRzID8gISFvcHRzLmFzeW5jIDogdHJ1ZVxuICBzY3JpcHQuc3JjID0gc3JjXG5cbiAgaWYgKG9wdHMuYXR0cnMpIHtcbiAgICBzZXRBdHRyaWJ1dGVzKHNjcmlwdCwgb3B0cy5hdHRycylcbiAgfVxuXG4gIGlmIChvcHRzLnRleHQpIHtcbiAgICBzY3JpcHQudGV4dCA9ICcnICsgb3B0cy50ZXh0XG4gIH1cblxuICB2YXIgb25lbmQgPSAnb25sb2FkJyBpbiBzY3JpcHQgPyBzdGRPbkVuZCA6IGllT25FbmRcbiAgb25lbmQoc2NyaXB0LCBjYilcblxuICAvLyBzb21lIGdvb2QgbGVnYWN5IGJyb3dzZXJzIChmaXJlZm94KSBmYWlsIHRoZSAnaW4nIGRldGVjdGlvbiBhYm92ZVxuICAvLyBzbyBhcyBhIGZhbGxiYWNrIHdlIGFsd2F5cyBzZXQgb25sb2FkXG4gIC8vIG9sZCBJRSB3aWxsIGlnbm9yZSB0aGlzIGFuZCBuZXcgSUUgd2lsbCBzZXQgb25sb2FkXG4gIGlmICghc2NyaXB0Lm9ubG9hZCkge1xuICAgIHN0ZE9uRW5kKHNjcmlwdCwgY2IpO1xuICB9XG5cbiAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoc2NyaXB0LCBhdHRycykge1xuICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgc2NyaXB0LnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RkT25FbmQgKHNjcmlwdCwgY2IpIHtcbiAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9ubG9hZCA9IG51bGxcbiAgICBjYihudWxsLCBzY3JpcHQpXG4gIH1cbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdGhpcy5vbmxvYWQgPSBudWxsIGhlcmUgaXMgbmVjZXNzYXJ5XG4gICAgLy8gYmVjYXVzZSBldmVuIElFOSB3b3JrcyBub3QgbGlrZSBvdGhlcnNcbiAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9ubG9hZCA9IG51bGxcbiAgICBjYihuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkICcgKyB0aGlzLnNyYyksIHNjcmlwdClcbiAgfVxufVxuXG5mdW5jdGlvbiBpZU9uRW5kIChzY3JpcHQsIGNiKSB7XG4gIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPSAnY29tcGxldGUnICYmIHRoaXMucmVhZHlTdGF0ZSAhPSAnbG9hZGVkJykgcmV0dXJuXG4gICAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgY2IobnVsbCwgc2NyaXB0KSAvLyB0aGVyZSBpcyBubyB3YXkgdG8gY2F0Y2ggbG9hZGluZyBlcnJvcnMgaW4gSUU4XG4gIH1cbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG5cdGlmICghb3B0aW9ucy5jdXN0b21NZXJnZSkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2Vcblx0fVxuXHR2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG5cdHJldHVybiB0eXBlb2YgY3VzdG9tTWVyZ2UgPT09ICdmdW5jdGlvbicgPyBjdXN0b21NZXJnZSA6IGRlZXBtZXJnZVxufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuXHRcdD8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRcdHJldHVybiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIHN5bWJvbClcblx0XHR9KVxuXHRcdDogW11cbn1cblxuZnVuY3Rpb24gZ2V0S2V5cyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlJc09uT2JqZWN0KG9iamVjdCwgcHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gcHJvcGVydHkgaW4gb2JqZWN0XG5cdH0gY2F0Y2goXykge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbi8vIFByb3RlY3RzIGZyb20gcHJvdG90eXBlIHBvaXNvbmluZyBhbmQgdW5leHBlY3RlZCBtZXJnaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5mdW5jdGlvbiBwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSB7XG5cdHJldHVybiBwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpIC8vIFByb3BlcnRpZXMgYXJlIHNhZmUgdG8gbWVyZ2UgaWYgdGhleSBkb24ndCBleGlzdCBpbiB0aGUgdGFyZ2V0IHlldCxcblx0XHQmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuXHRcdFx0JiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBrZXkpKSAvLyBhbmQgYWxzbyB1bnNhZmUgaWYgdGhleSdyZSBub25lbnVtZXJhYmxlLlxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdGdldEtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRnZXRLZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAocHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmIChwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pKSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0ID0gb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCB8fCBpc01lcmdlYWJsZU9iamVjdDtcblx0Ly8gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgaXMgYWRkZWQgdG8gYG9wdGlvbnNgIHNvIHRoYXQgY3VzdG9tIGFycmF5TWVyZ2UoKVxuXHQvLyBpbXBsZW1lbnRhdGlvbnMgY2FuIHVzZSBpdC4gVGhlIGNhbGxlciBtYXkgbm90IHJlcGxhY2UgaXQuXG5cdG9wdGlvbnMuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZDtcblxuXHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdHZhciBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcblxuXHRpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5hcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdH1cblxuXHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdH0sIHt9KVxufTtcblxudmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBtZXJnZV8xO1xuIiwgImltcG9ydCB7IHRlc3QgfSBmcm9tICd6b3JhJ1xuaW1wb3J0IHsgcmFuZG9tU3RyaW5nIH0gZnJvbSAnLi4vLi4vc3JjL3V0aWxzJ1xuXG50ZXN0KCdyZXR1cm5zIGEgNSBjaGFyYWN0ZXIgc3RyaW5nJywgdCA9PiB7XG4gIHQuaXModHlwZW9mIHJhbmRvbVN0cmluZygpLCAnc3RyaW5nJylcbiAgdC5pcyhyYW5kb21TdHJpbmcoKS5sZW5ndGgsIDUpXG59KVxuXG50ZXN0KCdyZXR1cm5zIGRpZmZlcmVudCBzdHJpbmdzJywgdCA9PiB7XG4gIGNvbnN0IGEgPSByYW5kb21TdHJpbmcoKVxuICBjb25zdCBiID0gcmFuZG9tU3RyaW5nKClcbiAgY29uc3QgYyA9IHJhbmRvbVN0cmluZygpXG4gIHQuaXNOb3QoYSwgYilcbiAgdC5pc05vdChhLCBjKVxuICB0LmlzTm90KGIsIGMpXG59KVxuIiwgImltcG9ydCBsb2FkU2NyaXB0IGZyb20gJ2xvYWQtc2NyaXB0J1xuaW1wb3J0IG1lcmdlIGZyb20gJ2RlZXBtZXJnZSdcblxuY29uc3QgTUFUQ0hfU1RBUlRfUVVFUlkgPSAvWz8mI10oPzpzdGFydHx0KT0oWzAtOWhtc10rKS9cbmNvbnN0IE1BVENIX0VORF9RVUVSWSA9IC9bPyYjXWVuZD0oWzAtOWhtc10rKS9cbmNvbnN0IE1BVENIX1NUQVJUX1NUQU1QID0gLyhcXGQrKShofG18cykvZ1xuY29uc3QgTUFUQ0hfTlVNRVJJQyA9IC9eXFxkKyQvXG5cbi8vIFBhcnNlIFlvdVR1YmUgVVJMIGZvciBhIHN0YXJ0IHRpbWUgcGFyYW0sIGllID90PTFoMTRtMzBzXG4vLyBhbmQgcmV0dXJuIHRoZSBzdGFydCB0aW1lIGluIHNlY29uZHNcbmZ1bmN0aW9uIHBhcnNlVGltZVBhcmFtICh1cmwsIHBhdHRlcm4pIHtcbiAgaWYgKHVybCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHBhdHRlcm4pXG4gIGlmIChtYXRjaCkge1xuICAgIGNvbnN0IHN0YW1wID0gbWF0Y2hbMV1cbiAgICBpZiAoc3RhbXAubWF0Y2goTUFUQ0hfU1RBUlRfU1RBTVApKSB7XG4gICAgICByZXR1cm4gcGFyc2VUaW1lU3RyaW5nKHN0YW1wKVxuICAgIH1cbiAgICBpZiAoTUFUQ0hfTlVNRVJJQy50ZXN0KHN0YW1wKSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHN0YW1wKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZVN0cmluZyAoc3RhbXApIHtcbiAgbGV0IHNlY29uZHMgPSAwXG4gIGxldCBhcnJheSA9IE1BVENIX1NUQVJUX1NUQU1QLmV4ZWMoc3RhbXApXG4gIHdoaWxlIChhcnJheSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IFssIGNvdW50LCBwZXJpb2RdID0gYXJyYXlcbiAgICBpZiAocGVyaW9kID09PSAnaCcpIHNlY29uZHMgKz0gcGFyc2VJbnQoY291bnQsIDEwKSAqIDYwICogNjBcbiAgICBpZiAocGVyaW9kID09PSAnbScpIHNlY29uZHMgKz0gcGFyc2VJbnQoY291bnQsIDEwKSAqIDYwXG4gICAgaWYgKHBlcmlvZCA9PT0gJ3MnKSBzZWNvbmRzICs9IHBhcnNlSW50KGNvdW50LCAxMClcbiAgICBhcnJheSA9IE1BVENIX1NUQVJUX1NUQU1QLmV4ZWMoc3RhbXApXG4gIH1cbiAgcmV0dXJuIHNlY29uZHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3RhcnRUaW1lICh1cmwpIHtcbiAgcmV0dXJuIHBhcnNlVGltZVBhcmFtKHVybCwgTUFUQ0hfU1RBUlRfUVVFUlkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVuZFRpbWUgKHVybCkge1xuICByZXR1cm4gcGFyc2VUaW1lUGFyYW0odXJsLCBNQVRDSF9FTkRfUVVFUlkpXG59XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM4NjIyNTQ1XG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU3RyaW5nICgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA1KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlTdHJpbmcgKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0XG4gICAgLmtleXMob2JqZWN0KVxuICAgIC5tYXAoa2V5ID0+IGAke2tleX09JHtvYmplY3Rba2V5XX1gKVxuICAgIC5qb2luKCcmJylcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsIChrZXkpIHtcbiAgaWYgKHdpbmRvd1trZXldKSB7XG4gICAgcmV0dXJuIHdpbmRvd1trZXldXG4gIH1cbiAgaWYgKHdpbmRvdy5leHBvcnRzICYmIHdpbmRvdy5leHBvcnRzW2tleV0pIHtcbiAgICByZXR1cm4gd2luZG93LmV4cG9ydHNba2V5XVxuICB9XG4gIGlmICh3aW5kb3cubW9kdWxlICYmIHdpbmRvdy5tb2R1bGUuZXhwb3J0cyAmJiB3aW5kb3cubW9kdWxlLmV4cG9ydHNba2V5XSkge1xuICAgIHJldHVybiB3aW5kb3cubW9kdWxlLmV4cG9ydHNba2V5XVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8vIFV0aWwgZnVuY3Rpb24gdG8gbG9hZCBhbiBleHRlcm5hbCBTREtcbi8vIG9yIHJldHVybiB0aGUgU0RLIGlmIGl0IGlzIGFscmVhZHkgbG9hZGVkXG5jb25zdCByZXF1ZXN0cyA9IHt9XG5leHBvcnQgY29uc3QgZ2V0U0RLID0gZW5hYmxlU3R1Yk9uKGZ1bmN0aW9uIGdldFNESyAodXJsLCBzZGtHbG9iYWwsIHNka1JlYWR5ID0gbnVsbCwgaXNMb2FkZWQgPSAoKSA9PiB0cnVlLCBmZXRjaFNjcmlwdCA9IGxvYWRTY3JpcHQpIHtcbiAgY29uc3QgZXhpc3RpbmdHbG9iYWwgPSBnZXRHbG9iYWwoc2RrR2xvYmFsKVxuICBpZiAoZXhpc3RpbmdHbG9iYWwgJiYgaXNMb2FkZWQoZXhpc3RpbmdHbG9iYWwpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShleGlzdGluZ0dsb2JhbClcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGxvYWRpbmcgdGhlIFNESywgYWRkIHRoZSByZXNvbHZlIGFuZCByZWplY3RcbiAgICAvLyBmdW5jdGlvbnMgdG8gdGhlIGV4aXN0aW5nIGFycmF5IG9mIHJlcXVlc3RzXG4gICAgaWYgKHJlcXVlc3RzW3VybF0pIHtcbiAgICAgIHJlcXVlc3RzW3VybF0ucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJlcXVlc3RzW3VybF0gPSBbeyByZXNvbHZlLCByZWplY3QgfV1cbiAgICBjb25zdCBvbkxvYWRlZCA9IHNkayA9PiB7XG4gICAgICAvLyBXaGVuIGxvYWRlZCwgcmVzb2x2ZSBhbGwgcGVuZGluZyByZXF1ZXN0IHByb21pc2VzXG4gICAgICByZXF1ZXN0c1t1cmxdLmZvckVhY2gocmVxdWVzdCA9PiByZXF1ZXN0LnJlc29sdmUoc2RrKSlcbiAgICB9XG4gICAgaWYgKHNka1JlYWR5KSB7XG4gICAgICBjb25zdCBwcmV2aW91c09uUmVhZHkgPSB3aW5kb3dbc2RrUmVhZHldXG4gICAgICB3aW5kb3dbc2RrUmVhZHldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJldmlvdXNPblJlYWR5KSBwcmV2aW91c09uUmVhZHkoKVxuICAgICAgICBvbkxvYWRlZChnZXRHbG9iYWwoc2RrR2xvYmFsKSlcbiAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hTY3JpcHQodXJsLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBMb2FkaW5nIHRoZSBTREsgZmFpbGVkIFx1MjAxMyByZWplY3QgYWxsIHJlcXVlc3RzIGFuZFxuICAgICAgICAvLyByZXNldCB0aGUgYXJyYXkgb2YgcmVxdWVzdHMgZm9yIHRoaXMgU0RLXG4gICAgICAgIHJlcXVlc3RzW3VybF0uZm9yRWFjaChyZXF1ZXN0ID0+IHJlcXVlc3QucmVqZWN0KGVycikpXG4gICAgICAgIHJlcXVlc3RzW3VybF0gPSBudWxsXG4gICAgICB9IGVsc2UgaWYgKCFzZGtSZWFkeSkge1xuICAgICAgICBvbkxvYWRlZChnZXRHbG9iYWwoc2RrR2xvYmFsKSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufSlcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbmZpZyAocHJvcHMsIGRlZmF1bHRQcm9wcykge1xuICByZXR1cm4gbWVyZ2UoZGVmYXVsdFByb3BzLmNvbmZpZywgcHJvcHMuY29uZmlnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb21pdCAob2JqZWN0LCAuLi5hcnJheXMpIHtcbiAgY29uc3Qgb21pdEtleXMgPSBbXS5jb25jYXQoLi4uYXJyYXlzKVxuICBjb25zdCBvdXRwdXQgPSB7fVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKG9taXRLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIG91dHB1dFtrZXldID0gb2JqZWN0W2tleV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbFBsYXllciAobWV0aG9kLCAuLi5hcmdzKSB7XG4gIC8vIFV0aWwgbWV0aG9kIGZvciBjYWxsaW5nIGEgbWV0aG9kIG9uIHRoaXMucGxheWVyXG4gIC8vIGJ1dCBndWFyZCBhZ2FpbnN0IGVycm9ycyBhbmQgY29uc29sZS53YXJuIGluc3RlYWRcbiAgaWYgKCF0aGlzLnBsYXllciB8fCAhdGhpcy5wbGF5ZXJbbWV0aG9kXSkge1xuICAgIGxldCBtZXNzYWdlID0gYFJlYWN0UGxheWVyOiAke3RoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWV9IHBsYXllciBjb3VsZCBub3QgY2FsbCAlYyR7bWV0aG9kfSVjIFx1MjAxMyBgXG4gICAgaWYgKCF0aGlzLnBsYXllcikge1xuICAgICAgbWVzc2FnZSArPSAnVGhlIHBsYXllciB3YXMgbm90IGF2YWlsYWJsZSdcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnBsYXllclttZXRob2RdKSB7XG4gICAgICBtZXNzYWdlICs9ICdUaGUgbWV0aG9kIHdhcyBub3QgYXZhaWxhYmxlJ1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSwgJ2ZvbnQtd2VpZ2h0OiBib2xkJywgJycpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gdGhpcy5wbGF5ZXJbbWV0aG9kXSguLi5hcmdzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNZWRpYVN0cmVhbSAodXJsKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93Lk1lZGlhU3RyZWFtICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHVybCBpbnN0YW5jZW9mIHdpbmRvdy5NZWRpYVN0cmVhbVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jsb2JVcmwgKHVybCkge1xuICByZXR1cm4gL15ibG9iOi8udGVzdCh1cmwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c1dlYktpdFByZXNlbnRhdGlvbk1vZGUgKHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKSkge1xuICAvLyBDaGVjayBpZiBTYWZhcmkgc3VwcG9ydHMgUGlQLCBhbmQgaXMgbm90IG9uIG1vYmlsZSAob3RoZXIgdGhhbiBpUGFkKVxuICAvLyBpUGhvbmUgc2FmYXJpIGFwcGVhcnMgdG8gXCJzdXBwb3J0XCIgUGlQIHRocm91Z2ggdGhlIGNoZWNrLCBob3dldmVyIFBpUCBkb2VzIG5vdCBmdW5jdGlvblxuICBjb25zdCBub3RNb2JpbGUgPSAvaVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IGZhbHNlXG4gIHJldHVybiB2aWRlby53ZWJraXRTdXBwb3J0c1ByZXNlbnRhdGlvbk1vZGUgJiYgdHlwZW9mIHZpZGVvLndlYmtpdFNldFByZXNlbnRhdGlvbk1vZGUgPT09ICdmdW5jdGlvbicgJiYgbm90TW9iaWxlXG59XG5cbi8vIFdvcmthcm91bmQgZm9yIGJlaW5nIGFibGUgdG8gc3R1YiBvdXQgZnVuY3Rpb25zIGluIEVTTSBleHBvcnRzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2VzYnVpbGQvaXNzdWVzLzQxMiNpc3N1ZWNvbW1lbnQtNzIzMDQ3MjU1XG5mdW5jdGlvbiBlbmFibGVTdHViT24gKGZuKSB7XG4gIGlmIChnbG9iYWxUaGlzLl9fVEVTVF9fKSB7XG4gICAgY29uc3Qgd3JhcCA9ICguLi5hcmdzKSA9PiB3cmFwLnN0dWIoLi4uYXJncylcbiAgICB3cmFwLnN0dWIgPSBmblxuICAgIHJldHVybiB3cmFwXG4gIH1cbiAgcmV0dXJuIGZuXG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQ0EsV0FBTyxVQUFVLFNBQVMsS0FBTSxLQUFLLE1BQU0sSUFBSTtBQUM3QyxVQUFJLE9BQU8sU0FBUyxRQUFRLFNBQVMscUJBQXFCLE1BQU0sRUFBRSxDQUFDO0FBQ25FLFVBQUksU0FBUyxTQUFTLGNBQWMsUUFBUTtBQUU1QyxVQUFJLE9BQU8sU0FBUyxZQUFZO0FBQzlCLGFBQUs7QUFDTCxlQUFPLENBQUM7QUFBQSxNQUNWO0FBRUEsYUFBTyxRQUFRLENBQUM7QUFDaEIsV0FBSyxNQUFNLFdBQVc7QUFBQSxNQUFDO0FBRXZCLGFBQU8sT0FBTyxLQUFLLFFBQVE7QUFDM0IsYUFBTyxVQUFVLEtBQUssV0FBVztBQUNqQyxhQUFPLFFBQVEsV0FBVyxPQUFPLENBQUMsQ0FBQyxLQUFLLFFBQVE7QUFDaEQsYUFBTyxNQUFNO0FBRWIsVUFBSSxLQUFLLE9BQU87QUFDZCxzQkFBYyxRQUFRLEtBQUssS0FBSztBQUFBLE1BQ2xDO0FBRUEsVUFBSSxLQUFLLE1BQU07QUFDYixlQUFPLE9BQU8sS0FBSyxLQUFLO0FBQUEsTUFDMUI7QUFFQSxVQUFJLFFBQVEsWUFBWSxTQUFTLFdBQVc7QUFDNUMsWUFBTSxRQUFRLEVBQUU7QUFLaEIsVUFBSSxDQUFDLE9BQU8sUUFBUTtBQUNsQixpQkFBUyxRQUFRLEVBQUU7QUFBQSxNQUNyQjtBQUVBLFdBQUssWUFBWSxNQUFNO0FBQUEsSUFD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QUFjLEdBQUc7QUFDOUMsV0FBTyxRQUFRLFFBQVEsY0FBYztBQUFBLEVBQ3ZDO0FBQ0EsU0FBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFHdEMsUUFBSSxTQUFTLEdBQUcsR0FBRztBQUNqQixlQUFTLEdBQUcsRUFBRSxLQUFLLEVBQUUsU0FBUyxPQUFPLENBQUM7QUFDdEM7QUFBQSxJQUNGO0FBQ0EsYUFBUyxHQUFHLElBQUksQ0FBQyxFQUFFLFNBQVMsT0FBTyxDQUFDO0FBQ3BDLFVBQU0sV0FBVyxTQUFPO0FBRXRCLGVBQVMsR0FBRyxFQUFFLFFBQVEsYUFBVyxRQUFRLFFBQVEsR0FBRyxDQUFDO0FBQUEsSUFDdkQ7QUFDQSxRQUFJLFVBQVU7QUFDWixZQUFNLGtCQUFrQixPQUFPLFFBQVE7QUFDdkMsYUFBTyxRQUFRLElBQUksV0FBWTtBQUM3QixZQUFJO0FBQWlCLDBCQUFnQjtBQUNyQyxpQkFBUyxVQUFVLFNBQVMsQ0FBQztBQUFBLE1BQy9CO0FBQUEsSUFDRjtBQUNBLGdCQUFZLEtBQUssU0FBTztBQUN0QixVQUFJLEtBQUs7QUFHUCxpQkFBUyxHQUFHLEVBQUUsUUFBUSxhQUFXLFFBQVEsT0FBTyxHQUFHLENBQUM7QUFDcEQsaUJBQVMsR0FBRyxJQUFJO0FBQUEsTUFDbEIsV0FBVyxDQUFDLFVBQVU7QUFDcEIsaUJBQVMsVUFBVSxTQUFTLENBQUM7QUFBQSxNQUMvQjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0gsQ0FBQztBQUNILENBQUM7QUF1REQsU0FBUyxhQUFjLElBQUk7QUFDekIsTUFBSSxNQUFxQjtBQUN2QixVQUFNLE9BQU8sSUFBSSxTQUFTLEtBQUssS0FBSyxHQUFHLElBQUk7QUFDM0MsU0FBSyxPQUFPO0FBQ1osV0FBTztBQUFBLEVBQ1Q7QUFDQSxTQUFPO0FBQ1Q7OztBRDFLQSxLQUFLLGdDQUFnQyxPQUFLO0FBQ3hDLElBQUUsR0FBRyxPQUFPLGFBQWEsR0FBRyxRQUFRO0FBQ3BDLElBQUUsR0FBRyxhQUFhLEVBQUUsUUFBUSxDQUFDO0FBQy9CLENBQUM7QUFFRCxLQUFLLDZCQUE2QixPQUFLO0FBQ3JDLFFBQU0sSUFBSSxhQUFhO0FBQ3ZCLFFBQU0sSUFBSSxhQUFhO0FBQ3ZCLFFBQU0sSUFBSSxhQUFhO0FBQ3ZCLElBQUUsTUFBTSxHQUFHLENBQUM7QUFDWixJQUFFLE1BQU0sR0FBRyxDQUFDO0FBQ1osSUFBRSxNQUFNLEdBQUcsQ0FBQztBQUNkLENBQUM7IiwKICAibmFtZXMiOiBbImlzTWVyZ2VhYmxlT2JqZWN0IiwgImdldFNESyIsICJsb2FkU2NyaXB0Il0KfQo=
