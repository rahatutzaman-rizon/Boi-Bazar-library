var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/load-script/index.js
var require_load_script = __commonJS({
  "node_modules/load-script/index.js"(exports, module) {
    module.exports = function load(src, opts, cb) {
      var head = document.head || document.getElementsByTagName("head")[0];
      var script = document.createElement("script");
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      opts = opts || {};
      cb = cb || function() {
      };
      script.type = opts.type || "text/javascript";
      script.charset = opts.charset || "utf8";
      script.async = "async" in opts ? !!opts.async : true;
      script.src = src;
      if (opts.attrs) {
        setAttributes(script, opts.attrs);
      }
      if (opts.text) {
        script.text = "" + opts.text;
      }
      var onend = "onload" in script ? stdOnEnd : ieOnEnd;
      onend(script, cb);
      if (!script.onload) {
        stdOnEnd(script, cb);
      }
      head.appendChild(script);
    };
    function setAttributes(script, attrs) {
      for (var attr in attrs) {
        script.setAttribute(attr, attrs[attr]);
      }
    }
    function stdOnEnd(script, cb) {
      script.onload = function() {
        this.onerror = this.onload = null;
        cb(null, script);
      };
      script.onerror = function() {
        this.onerror = this.onload = null;
        cb(new Error("Failed to load " + this.src), script);
      };
    }
    function ieOnEnd(script, cb) {
      script.onreadystatechange = function() {
        if (this.readyState != "complete" && this.readyState != "loaded")
          return;
        this.onreadystatechange = null;
        cb(null, script);
      };
    }
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// test/utils/callPlayer.js
import { test } from "zora";
import sinon from "sinon";

// src/utils.js
var import_load_script = __toESM(require_load_script());
var import_deepmerge = __toESM(require_cjs());
function getGlobal(key) {
  if (window[key]) {
    return window[key];
  }
  if (window.exports && window.exports[key]) {
    return window.exports[key];
  }
  if (window.module && window.module.exports && window.module.exports[key]) {
    return window.module.exports[key];
  }
  return null;
}
var requests = {};
var getSDK = enableStubOn(function getSDK2(url, sdkGlobal, sdkReady = null, isLoaded = () => true, fetchScript = import_load_script.default) {
  const existingGlobal = getGlobal(sdkGlobal);
  if (existingGlobal && isLoaded(existingGlobal)) {
    return Promise.resolve(existingGlobal);
  }
  return new Promise((resolve, reject) => {
    if (requests[url]) {
      requests[url].push({ resolve, reject });
      return;
    }
    requests[url] = [{ resolve, reject }];
    const onLoaded = (sdk) => {
      requests[url].forEach((request) => request.resolve(sdk));
    };
    if (sdkReady) {
      const previousOnReady = window[sdkReady];
      window[sdkReady] = function() {
        if (previousOnReady)
          previousOnReady();
        onLoaded(getGlobal(sdkGlobal));
      };
    }
    fetchScript(url, (err) => {
      if (err) {
        requests[url].forEach((request) => request.reject(err));
        requests[url] = null;
      } else if (!sdkReady) {
        onLoaded(getGlobal(sdkGlobal));
      }
    });
  });
});
function callPlayer(method, ...args) {
  if (!this.player || !this.player[method]) {
    let message = `ReactPlayer: ${this.constructor.displayName} player could not call %c${method}%c \u2013 `;
    if (!this.player) {
      message += "The player was not available";
    } else if (!this.player[method]) {
      message += "The method was not available";
    }
    console.warn(message, "font-weight: bold", "");
    return null;
  }
  return this.player[method](...args);
}
function enableStubOn(fn) {
  if (true) {
    const wrap = (...args) => wrap.stub(...args);
    wrap.stub = fn;
    return wrap;
  }
  return fn;
}

// test/utils/callPlayer.js
test("calls a player method", (t) => {
  const fakePlayer = {
    player: {
      testMethod: () => "result"
    }
  };
  t.is(callPlayer.call(fakePlayer, "testMethod"), "result");
});
test("returns null when player is not available", (t) => {
  const stub = sinon.stub(console, "warn");
  const fakePlayer = {
    constructor: {
      displayName: "TestPlayer"
    },
    player: null
  };
  t.is(callPlayer.call(fakePlayer, "testMethod"), null);
  t.ok(stub.calledOnce);
  stub.restore();
});
test("returns null when method is not available", (t) => {
  const stub = sinon.stub(console, "warn");
  const fakePlayer = {
    constructor: {
      displayName: "TestPlayer"
    },
    player: {
      testMethod: null
    }
  };
  t.is(callPlayer.call(fakePlayer, "testMethod"), null);
  t.ok(stub.calledOnce);
  stub.restore();
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL2xvYWQtc2NyaXB0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanMiLCAiLi4vLi4vdGVzdC91dGlscy9jYWxsUGxheWVyLmpzIiwgIi4uLy4uL3NyYy91dGlscy5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvYWQgKHNyYywgb3B0cywgY2IpIHtcbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF1cbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fVxuICBjYiA9IGNiIHx8IGZ1bmN0aW9uKCkge31cblxuICBzY3JpcHQudHlwZSA9IG9wdHMudHlwZSB8fCAndGV4dC9qYXZhc2NyaXB0J1xuICBzY3JpcHQuY2hhcnNldCA9IG9wdHMuY2hhcnNldCB8fCAndXRmOCc7XG4gIHNjcmlwdC5hc3luYyA9ICdhc3luYycgaW4gb3B0cyA/ICEhb3B0cy5hc3luYyA6IHRydWVcbiAgc2NyaXB0LnNyYyA9IHNyY1xuXG4gIGlmIChvcHRzLmF0dHJzKSB7XG4gICAgc2V0QXR0cmlidXRlcyhzY3JpcHQsIG9wdHMuYXR0cnMpXG4gIH1cblxuICBpZiAob3B0cy50ZXh0KSB7XG4gICAgc2NyaXB0LnRleHQgPSAnJyArIG9wdHMudGV4dFxuICB9XG5cbiAgdmFyIG9uZW5kID0gJ29ubG9hZCcgaW4gc2NyaXB0ID8gc3RkT25FbmQgOiBpZU9uRW5kXG4gIG9uZW5kKHNjcmlwdCwgY2IpXG5cbiAgLy8gc29tZSBnb29kIGxlZ2FjeSBicm93c2VycyAoZmlyZWZveCkgZmFpbCB0aGUgJ2luJyBkZXRlY3Rpb24gYWJvdmVcbiAgLy8gc28gYXMgYSBmYWxsYmFjayB3ZSBhbHdheXMgc2V0IG9ubG9hZFxuICAvLyBvbGQgSUUgd2lsbCBpZ25vcmUgdGhpcyBhbmQgbmV3IElFIHdpbGwgc2V0IG9ubG9hZFxuICBpZiAoIXNjcmlwdC5vbmxvYWQpIHtcbiAgICBzdGRPbkVuZChzY3JpcHQsIGNiKTtcbiAgfVxuXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKHNjcmlwdCwgYXR0cnMpIHtcbiAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0ZE9uRW5kIChzY3JpcHQsIGNiKSB7XG4gIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmxvYWQgPSBudWxsXG4gICAgY2IobnVsbCwgc2NyaXB0KVxuICB9XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHRoaXMub25sb2FkID0gbnVsbCBoZXJlIGlzIG5lY2Vzc2FyeVxuICAgIC8vIGJlY2F1c2UgZXZlbiBJRTkgd29ya3Mgbm90IGxpa2Ugb3RoZXJzXG4gICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmxvYWQgPSBudWxsXG4gICAgY2IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCAnICsgdGhpcy5zcmMpLCBzY3JpcHQpXG4gIH1cbn1cblxuZnVuY3Rpb24gaWVPbkVuZCAoc2NyaXB0LCBjYikge1xuICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT0gJ2NvbXBsZXRlJyAmJiB0aGlzLnJlYWR5U3RhdGUgIT0gJ2xvYWRlZCcpIHJldHVyblxuICAgIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgIGNiKG51bGwsIHNjcmlwdCkgLy8gdGhlcmUgaXMgbm8gd2F5IHRvIGNhdGNoIGxvYWRpbmcgZXJyb3JzIGluIElFOFxuICB9XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRyZXR1cm4gc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxufVxuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKVxuXHRcdDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMuY3VzdG9tTWVyZ2UpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlXG5cdH1cblx0dmFyIGN1c3RvbU1lcmdlID0gb3B0aW9ucy5jdXN0b21NZXJnZShrZXkpO1xuXHRyZXR1cm4gdHlwZW9mIGN1c3RvbU1lcmdlID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWVyZ2UgOiBkZWVwbWVyZ2Vcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBzeW1ib2wpXG5cdFx0fSlcblx0XHQ6IFtdXG59XG5cbmZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLmNvbmNhdChnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5IGluIG9iamVjdFxuXHR9IGNhdGNoKF8pIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG4vLyBQcm90ZWN0cyBmcm9tIHByb3RvdHlwZSBwb2lzb25pbmcgYW5kIHVuZXhwZWN0ZWQgbWVyZ2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuZnVuY3Rpb24gcHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkge1xuXHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0JiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkgLy8gdW5zYWZlIGlmIHRoZXkgZXhpc3QgdXAgdGhlIHByb3RvdHlwZSBjaGFpbixcblx0XHRcdCYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwga2V5KSkgLy8gYW5kIGFsc28gdW5zYWZlIGlmIHRoZXkncmUgbm9uZW51bWVyYWJsZS5cbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cblx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0Ly8gaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgaXQuIFRoZSBjYWxsZXIgbWF5IG5vdCByZXBsYWNlIGl0LlxuXHRvcHRpb25zLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQ7XG5cblx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuXHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXknKVxuXHR9XG5cblx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zKVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwbWVyZ2VfMTtcbiIsICJpbXBvcnQgeyB0ZXN0IH0gZnJvbSAnem9yYSdcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbidcbmltcG9ydCB7IGNhbGxQbGF5ZXIgfSBmcm9tICcuLi8uLi9zcmMvdXRpbHMnXG5cbnRlc3QoJ2NhbGxzIGEgcGxheWVyIG1ldGhvZCcsIHQgPT4ge1xuICBjb25zdCBmYWtlUGxheWVyID0ge1xuICAgIHBsYXllcjoge1xuICAgICAgdGVzdE1ldGhvZDogKCkgPT4gJ3Jlc3VsdCdcbiAgICB9XG4gIH1cbiAgdC5pcyhjYWxsUGxheWVyLmNhbGwoZmFrZVBsYXllciwgJ3Rlc3RNZXRob2QnKSwgJ3Jlc3VsdCcpXG59KVxuXG50ZXN0KCdyZXR1cm5zIG51bGwgd2hlbiBwbGF5ZXIgaXMgbm90IGF2YWlsYWJsZScsIHQgPT4ge1xuICBjb25zdCBzdHViID0gc2lub24uc3R1Yihjb25zb2xlLCAnd2FybicpXG4gIGNvbnN0IGZha2VQbGF5ZXIgPSB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIGRpc3BsYXlOYW1lOiAnVGVzdFBsYXllcidcbiAgICB9LFxuICAgIHBsYXllcjogbnVsbFxuICB9XG4gIHQuaXMoY2FsbFBsYXllci5jYWxsKGZha2VQbGF5ZXIsICd0ZXN0TWV0aG9kJyksIG51bGwpXG4gIHQub2soc3R1Yi5jYWxsZWRPbmNlKVxuICBzdHViLnJlc3RvcmUoKVxufSlcblxudGVzdCgncmV0dXJucyBudWxsIHdoZW4gbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUnLCB0ID0+IHtcbiAgY29uc3Qgc3R1YiA9IHNpbm9uLnN0dWIoY29uc29sZSwgJ3dhcm4nKVxuICBjb25zdCBmYWtlUGxheWVyID0ge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICBkaXNwbGF5TmFtZTogJ1Rlc3RQbGF5ZXInXG4gICAgfSxcbiAgICBwbGF5ZXI6IHtcbiAgICAgIHRlc3RNZXRob2Q6IG51bGxcbiAgICB9XG4gIH1cbiAgdC5pcyhjYWxsUGxheWVyLmNhbGwoZmFrZVBsYXllciwgJ3Rlc3RNZXRob2QnKSwgbnVsbClcbiAgdC5vayhzdHViLmNhbGxlZE9uY2UpXG4gIHN0dWIucmVzdG9yZSgpXG59KVxuIiwgImltcG9ydCBsb2FkU2NyaXB0IGZyb20gJ2xvYWQtc2NyaXB0J1xuaW1wb3J0IG1lcmdlIGZyb20gJ2RlZXBtZXJnZSdcblxuY29uc3QgTUFUQ0hfU1RBUlRfUVVFUlkgPSAvWz8mI10oPzpzdGFydHx0KT0oWzAtOWhtc10rKS9cbmNvbnN0IE1BVENIX0VORF9RVUVSWSA9IC9bPyYjXWVuZD0oWzAtOWhtc10rKS9cbmNvbnN0IE1BVENIX1NUQVJUX1NUQU1QID0gLyhcXGQrKShofG18cykvZ1xuY29uc3QgTUFUQ0hfTlVNRVJJQyA9IC9eXFxkKyQvXG5cbi8vIFBhcnNlIFlvdVR1YmUgVVJMIGZvciBhIHN0YXJ0IHRpbWUgcGFyYW0sIGllID90PTFoMTRtMzBzXG4vLyBhbmQgcmV0dXJuIHRoZSBzdGFydCB0aW1lIGluIHNlY29uZHNcbmZ1bmN0aW9uIHBhcnNlVGltZVBhcmFtICh1cmwsIHBhdHRlcm4pIHtcbiAgaWYgKHVybCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHBhdHRlcm4pXG4gIGlmIChtYXRjaCkge1xuICAgIGNvbnN0IHN0YW1wID0gbWF0Y2hbMV1cbiAgICBpZiAoc3RhbXAubWF0Y2goTUFUQ0hfU1RBUlRfU1RBTVApKSB7XG4gICAgICByZXR1cm4gcGFyc2VUaW1lU3RyaW5nKHN0YW1wKVxuICAgIH1cbiAgICBpZiAoTUFUQ0hfTlVNRVJJQy50ZXN0KHN0YW1wKSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHN0YW1wKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZVN0cmluZyAoc3RhbXApIHtcbiAgbGV0IHNlY29uZHMgPSAwXG4gIGxldCBhcnJheSA9IE1BVENIX1NUQVJUX1NUQU1QLmV4ZWMoc3RhbXApXG4gIHdoaWxlIChhcnJheSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IFssIGNvdW50LCBwZXJpb2RdID0gYXJyYXlcbiAgICBpZiAocGVyaW9kID09PSAnaCcpIHNlY29uZHMgKz0gcGFyc2VJbnQoY291bnQsIDEwKSAqIDYwICogNjBcbiAgICBpZiAocGVyaW9kID09PSAnbScpIHNlY29uZHMgKz0gcGFyc2VJbnQoY291bnQsIDEwKSAqIDYwXG4gICAgaWYgKHBlcmlvZCA9PT0gJ3MnKSBzZWNvbmRzICs9IHBhcnNlSW50KGNvdW50LCAxMClcbiAgICBhcnJheSA9IE1BVENIX1NUQVJUX1NUQU1QLmV4ZWMoc3RhbXApXG4gIH1cbiAgcmV0dXJuIHNlY29uZHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3RhcnRUaW1lICh1cmwpIHtcbiAgcmV0dXJuIHBhcnNlVGltZVBhcmFtKHVybCwgTUFUQ0hfU1RBUlRfUVVFUlkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVuZFRpbWUgKHVybCkge1xuICByZXR1cm4gcGFyc2VUaW1lUGFyYW0odXJsLCBNQVRDSF9FTkRfUVVFUlkpXG59XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM4NjIyNTQ1XG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU3RyaW5nICgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA1KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlTdHJpbmcgKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0XG4gICAgLmtleXMob2JqZWN0KVxuICAgIC5tYXAoa2V5ID0+IGAke2tleX09JHtvYmplY3Rba2V5XX1gKVxuICAgIC5qb2luKCcmJylcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsIChrZXkpIHtcbiAgaWYgKHdpbmRvd1trZXldKSB7XG4gICAgcmV0dXJuIHdpbmRvd1trZXldXG4gIH1cbiAgaWYgKHdpbmRvdy5leHBvcnRzICYmIHdpbmRvdy5leHBvcnRzW2tleV0pIHtcbiAgICByZXR1cm4gd2luZG93LmV4cG9ydHNba2V5XVxuICB9XG4gIGlmICh3aW5kb3cubW9kdWxlICYmIHdpbmRvdy5tb2R1bGUuZXhwb3J0cyAmJiB3aW5kb3cubW9kdWxlLmV4cG9ydHNba2V5XSkge1xuICAgIHJldHVybiB3aW5kb3cubW9kdWxlLmV4cG9ydHNba2V5XVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8vIFV0aWwgZnVuY3Rpb24gdG8gbG9hZCBhbiBleHRlcm5hbCBTREtcbi8vIG9yIHJldHVybiB0aGUgU0RLIGlmIGl0IGlzIGFscmVhZHkgbG9hZGVkXG5jb25zdCByZXF1ZXN0cyA9IHt9XG5leHBvcnQgY29uc3QgZ2V0U0RLID0gZW5hYmxlU3R1Yk9uKGZ1bmN0aW9uIGdldFNESyAodXJsLCBzZGtHbG9iYWwsIHNka1JlYWR5ID0gbnVsbCwgaXNMb2FkZWQgPSAoKSA9PiB0cnVlLCBmZXRjaFNjcmlwdCA9IGxvYWRTY3JpcHQpIHtcbiAgY29uc3QgZXhpc3RpbmdHbG9iYWwgPSBnZXRHbG9iYWwoc2RrR2xvYmFsKVxuICBpZiAoZXhpc3RpbmdHbG9iYWwgJiYgaXNMb2FkZWQoZXhpc3RpbmdHbG9iYWwpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShleGlzdGluZ0dsb2JhbClcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGxvYWRpbmcgdGhlIFNESywgYWRkIHRoZSByZXNvbHZlIGFuZCByZWplY3RcbiAgICAvLyBmdW5jdGlvbnMgdG8gdGhlIGV4aXN0aW5nIGFycmF5IG9mIHJlcXVlc3RzXG4gICAgaWYgKHJlcXVlc3RzW3VybF0pIHtcbiAgICAgIHJlcXVlc3RzW3VybF0ucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJlcXVlc3RzW3VybF0gPSBbeyByZXNvbHZlLCByZWplY3QgfV1cbiAgICBjb25zdCBvbkxvYWRlZCA9IHNkayA9PiB7XG4gICAgICAvLyBXaGVuIGxvYWRlZCwgcmVzb2x2ZSBhbGwgcGVuZGluZyByZXF1ZXN0IHByb21pc2VzXG4gICAgICByZXF1ZXN0c1t1cmxdLmZvckVhY2gocmVxdWVzdCA9PiByZXF1ZXN0LnJlc29sdmUoc2RrKSlcbiAgICB9XG4gICAgaWYgKHNka1JlYWR5KSB7XG4gICAgICBjb25zdCBwcmV2aW91c09uUmVhZHkgPSB3aW5kb3dbc2RrUmVhZHldXG4gICAgICB3aW5kb3dbc2RrUmVhZHldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJldmlvdXNPblJlYWR5KSBwcmV2aW91c09uUmVhZHkoKVxuICAgICAgICBvbkxvYWRlZChnZXRHbG9iYWwoc2RrR2xvYmFsKSlcbiAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hTY3JpcHQodXJsLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBMb2FkaW5nIHRoZSBTREsgZmFpbGVkIFx1MjAxMyByZWplY3QgYWxsIHJlcXVlc3RzIGFuZFxuICAgICAgICAvLyByZXNldCB0aGUgYXJyYXkgb2YgcmVxdWVzdHMgZm9yIHRoaXMgU0RLXG4gICAgICAgIHJlcXVlc3RzW3VybF0uZm9yRWFjaChyZXF1ZXN0ID0+IHJlcXVlc3QucmVqZWN0KGVycikpXG4gICAgICAgIHJlcXVlc3RzW3VybF0gPSBudWxsXG4gICAgICB9IGVsc2UgaWYgKCFzZGtSZWFkeSkge1xuICAgICAgICBvbkxvYWRlZChnZXRHbG9iYWwoc2RrR2xvYmFsKSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufSlcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbmZpZyAocHJvcHMsIGRlZmF1bHRQcm9wcykge1xuICByZXR1cm4gbWVyZ2UoZGVmYXVsdFByb3BzLmNvbmZpZywgcHJvcHMuY29uZmlnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb21pdCAob2JqZWN0LCAuLi5hcnJheXMpIHtcbiAgY29uc3Qgb21pdEtleXMgPSBbXS5jb25jYXQoLi4uYXJyYXlzKVxuICBjb25zdCBvdXRwdXQgPSB7fVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKG9taXRLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIG91dHB1dFtrZXldID0gb2JqZWN0W2tleV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbFBsYXllciAobWV0aG9kLCAuLi5hcmdzKSB7XG4gIC8vIFV0aWwgbWV0aG9kIGZvciBjYWxsaW5nIGEgbWV0aG9kIG9uIHRoaXMucGxheWVyXG4gIC8vIGJ1dCBndWFyZCBhZ2FpbnN0IGVycm9ycyBhbmQgY29uc29sZS53YXJuIGluc3RlYWRcbiAgaWYgKCF0aGlzLnBsYXllciB8fCAhdGhpcy5wbGF5ZXJbbWV0aG9kXSkge1xuICAgIGxldCBtZXNzYWdlID0gYFJlYWN0UGxheWVyOiAke3RoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWV9IHBsYXllciBjb3VsZCBub3QgY2FsbCAlYyR7bWV0aG9kfSVjIFx1MjAxMyBgXG4gICAgaWYgKCF0aGlzLnBsYXllcikge1xuICAgICAgbWVzc2FnZSArPSAnVGhlIHBsYXllciB3YXMgbm90IGF2YWlsYWJsZSdcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnBsYXllclttZXRob2RdKSB7XG4gICAgICBtZXNzYWdlICs9ICdUaGUgbWV0aG9kIHdhcyBub3QgYXZhaWxhYmxlJ1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSwgJ2ZvbnQtd2VpZ2h0OiBib2xkJywgJycpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gdGhpcy5wbGF5ZXJbbWV0aG9kXSguLi5hcmdzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNZWRpYVN0cmVhbSAodXJsKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93Lk1lZGlhU3RyZWFtICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHVybCBpbnN0YW5jZW9mIHdpbmRvdy5NZWRpYVN0cmVhbVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jsb2JVcmwgKHVybCkge1xuICByZXR1cm4gL15ibG9iOi8udGVzdCh1cmwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c1dlYktpdFByZXNlbnRhdGlvbk1vZGUgKHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKSkge1xuICAvLyBDaGVjayBpZiBTYWZhcmkgc3VwcG9ydHMgUGlQLCBhbmQgaXMgbm90IG9uIG1vYmlsZSAob3RoZXIgdGhhbiBpUGFkKVxuICAvLyBpUGhvbmUgc2FmYXJpIGFwcGVhcnMgdG8gXCJzdXBwb3J0XCIgUGlQIHRocm91Z2ggdGhlIGNoZWNrLCBob3dldmVyIFBpUCBkb2VzIG5vdCBmdW5jdGlvblxuICBjb25zdCBub3RNb2JpbGUgPSAvaVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IGZhbHNlXG4gIHJldHVybiB2aWRlby53ZWJraXRTdXBwb3J0c1ByZXNlbnRhdGlvbk1vZGUgJiYgdHlwZW9mIHZpZGVvLndlYmtpdFNldFByZXNlbnRhdGlvbk1vZGUgPT09ICdmdW5jdGlvbicgJiYgbm90TW9iaWxlXG59XG5cbi8vIFdvcmthcm91bmQgZm9yIGJlaW5nIGFibGUgdG8gc3R1YiBvdXQgZnVuY3Rpb25zIGluIEVTTSBleHBvcnRzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2VzYnVpbGQvaXNzdWVzLzQxMiNpc3N1ZWNvbW1lbnQtNzIzMDQ3MjU1XG5mdW5jdGlvbiBlbmFibGVTdHViT24gKGZuKSB7XG4gIGlmIChnbG9iYWxUaGlzLl9fVEVTVF9fKSB7XG4gICAgY29uc3Qgd3JhcCA9ICguLi5hcmdzKSA9PiB3cmFwLnN0dWIoLi4uYXJncylcbiAgICB3cmFwLnN0dWIgPSBmblxuICAgIHJldHVybiB3cmFwXG4gIH1cbiAgcmV0dXJuIGZuXG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQ0EsV0FBTyxVQUFVLFNBQVMsS0FBTSxLQUFLLE1BQU0sSUFB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TSxPQUFPLE1BQU0sS0FBSyxTQUFTLE1BQU07QUFDdkMsUUFBTSxhQUFhO0FBQUEsSUFDakIsYUFBYTtBQUFBLE1BQ1gsYUFBYTtBQUFBLElBQ2Y7QUFBQSxJQUNBLFFBQVE7QUFBQSxFQUNWO0FBQ0EsSUFBRSxHQUFHLFdBQVcsS0FBSyxZQUFZLFlBQVksR0FBRyxJQUFJO0FBQ3BELElBQUUsR0FBRyxLQUFLLFVBQVU7QUFDcEIsT0FBSyxRQUFRO0FBQ2YsQ0FBQztBQUVELEtBQUssNkNBQTZDLE9BQUs7QUFDckQsUUFBTSxPQUFPLE1BQU0sS0FBSyxTQUFTLE1BQU07QUFDdkMsUUFBTSxhQUFhO0FBQUEsSUFDakIsYUFBYTtBQUFBLE1BQ1gsYUFBYTtBQUFBLElBQ2Y7QUFBQSxJQUNBLFFBQVE7QUFBQSxNQUNOLFlBQVk7QUFBQSxJQUNkO0FBQUEsRUFDRjtBQUNBLElBQUUsR0FBRyxXQUFXLEtBQUssWUFBWSxZQUFZLEdBQUcsSUFBSTtBQUNwRCxJQUFFLEdBQUcsS0FBSyxVQUFVO0FBQ3BCLE9BQUssUUFBUTtBQUNmLENBQUM7IiwKICAibmFtZXMiOiBbImlzTWVyZ2VhYmxlT2JqZWN0IiwgImdldFNESyIsICJsb2FkU2NyaXB0Il0KfQo=
